package org.olexec.service;

import org.olexec.core.ClassRunner;
import org.olexec.core.SourceCompiler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaFileObject;
import java.util.List;
import java.util.concurrent.*;

/**
 * Facade that glues together compilation and execution.
 * <p>
 * Steps per request:
 * 1. Compile the incoming Java source via {@link org.olexec.compile.StringSourceCompiler}.
 * 2. If compilation fails – build a readable diagnostics string from the
 *    {@link javax.tools.DiagnosticCollector} and return it to the caller.
 * 3. If compilation succeeds – run the generated byte-code inside a sandbox
 *    ({@link org.olexec.execute.JavaClassExecutor}) with a hard timeout
 *    (15 seconds by default).
 * 4. Return either console output or a runtime error message.
 */
@Service
public class ExecuteStringSourceService {
    /** Maximum wall-clock time (seconds) a user program is allowed to run. */
    private static final int RUN_TIME_LIMITED = 15;

    @Autowired
    private ExecutorService userCodeExecutor;

    private static final String WAIT_WARNING = "Server is busy, please submit again later.";
    private static final String NO_OUTPUT = "Nothing.";

    @Autowired
    private SourceCompiler compiler;

    @Autowired
    private ClassRunner classRunner;

    public String execute(String source, String systemIn) {
        // Collects diagnostics (errors/warnings) produced during compilation.
        DiagnosticCollector<JavaFileObject> compileCollector = new DiagnosticCollector<>();

        // Compile source code
        byte[] classBytes = compiler.compile(source, compileCollector);

        // If compilation fails, build a human-readable diagnostics string and return it
        if (classBytes == null) {
            // Extract compile-time errors
            List<Diagnostic<? extends JavaFileObject>> compileError = compileCollector.getDiagnostics();
            StringBuilder compileErrorRes = new StringBuilder();
            for (Diagnostic diagnostic : compileError) {
                compileErrorRes.append("Compilation error at ");
                compileErrorRes.append(diagnostic.getLineNumber());
                compileErrorRes.append(".");
                compileErrorRes.append(System.lineSeparator());
            }
            return compileErrorRes.toString();
        }

        // Run the compiled class's main method
        Callable<String> runTask = () -> classRunner.run(classBytes, systemIn);

        Future<String> res = null;
        try {
            res = userCodeExecutor.submit(runTask);
        } catch (RejectedExecutionException e) {
            return WAIT_WARNING;
        }

        // Retrieve execution result; convert non-user exceptions to friendly messages
        String runResult;
        try {
            runResult = res.get(RUN_TIME_LIMITED, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            runResult = "Program interrupted.";
        } catch (ExecutionException e) {
            runResult = e.getCause().getMessage();
        } catch (TimeoutException e) {
            runResult = "Time Limit Exceeded.";
        } finally {
            res.cancel(true);
        }
        return runResult != null ? runResult : NO_OUTPUT;
    }
}
